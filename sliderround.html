<!DOCTYPE html>
<html>
  <body>
    <div id="axisContainer"></div>
    <script>
      function createPointerCircle(
        diameter,
        xPosition,
        yPosition,
        circleColor
      ) {
        const circle = document.createElement('div');

        circle.style.width = `${diameter}px`;
        circle.style.height = `${diameter}px`;
        circle.style.backgroundColor = circleColor;
        circle.style.borderRadius = '50%';
        circle.style.position = 'absolute';
        circle.style.left = `${xPosition - diameter / 2}px`;
        circle.style.top = `${yPosition - diameter / 2}px`;

        return circle;
      }

      const isVertical = 0; // Set to true for vertical layout, false for horizontal
      const X = 630; // Length of the main line
      const Y = 10; // Number of segments
      const axisColorLo = ''; //transparent
      const axisColorIn = 'red';
      const axisColorHi = axisColorLo;
      const axisColorMain = 'black';
      const pointerColorNonSelected = 'black';
      const pointerColorSelected = 'orange';
      const ticksVisible = 'hidden';
      const pointerSize = window.innerWidth / 30;
      const segmentDimension = pointerSize / 2;
      const pointerRadius = pointerSize / 2;
      const extraSpace = 0.5;
      const unit = X / (Y - 1);
      let currIndexLo = 5;
      let currIndexHi = 7;

      const axisContainer = document.getElementById('axisContainer');
      axisContainer.style[isVertical ? 'height' : 'width'] = `${
        X + 2 * unit * extraSpace
      }px`;
      axisContainer.style[
        isVertical ? 'width' : 'height'
      ] = `${segmentDimension}px`;
      axisContainer.style.margin = '0';
      axisContainer.style.padding = '0';
      axisContainer.style.position = 'relative';

      const mainAxis = document.createElement('div');
      mainAxis.id = 'mainAxis';
      mainAxis.style[isVertical ? 'height' : 'width'] = `${
        X + 2 * unit * extraSpace
      }px`;
      mainAxis.style[isVertical ? 'width' : 'height'] = '2px';
      mainAxis.style[isVertical ? 'left' : 'top'] = `${segmentDimension / 2}px`;
      mainAxis.style.backgroundColor = `${axisColorMain}`;
      mainAxis.style.margin = '0';
      mainAxis.style.padding = '0';
      mainAxis.style.position = 'absolute';

      const extraSegment = document.createAttribute;

      const extraSegmentBefore = document.createElement('div');
      extraSegmentBefore.style[isVertical ? 'top' : 'left'] = `0px`;
      extraSegmentBefore.style.position = 'absolute';
      extraSegmentBefore.style[
        isVertical ? 'width' : 'height'
      ] = `${segmentDimension}px`;
      extraSegmentBefore.style[isVertical ? 'height' : 'width'] = `${
        unit * extraSpace
      }px`;
      extraSegmentBefore.style.backgroundColor = 'blue';

      axisContainer.appendChild(extraSegmentBefore);
      axisContainer.appendChild(mainAxis);

      const extraSegmentAfter = document.createElement('div');
      extraSegmentAfter.style[isVertical ? 'top' : 'left'] = `${
        X + unit * extraSpace
      }px`;
      extraSegmentAfter.style.position = 'absolute';
      extraSegmentAfter.style[
        isVertical ? 'width' : 'height'
      ] = `${segmentDimension}px`;
      extraSegmentAfter.style[isVertical ? 'height' : 'width'] = `${
        unit * extraSpace
      }px`;
      extraSegmentAfter.style.backgroundColor = 'blue';
      extraSegmentAfter.style.zIndex = '-1';

      axisContainer.appendChild(extraSegmentAfter);

      const segments = [];
      for (let i = 0; i < Y - 1; i++) {
        segment = document.createElement('div');
        segment.style.position = 'absolute';
        segment.style[
          isVertical ? 'width' : 'height'
        ] = `${segmentDimension}px`;
        segment.style[isVertical ? 'height' : 'width'] = `${unit}px`;
        segment.style.backgroundColor = '';
        segment.style[isVertical ? 'top' : 'left'] = `${
          (i + extraSpace) * unit
        }px`;
        axisContainer.appendChild(segment);
        segments.push(segment);
      }

      const ticks = [];
      for (let i = 0; i < Y; i++) {
        const tick = document.createElement('div');
        tick.style.visibility = ticksVisible;
        tick.style.position = 'absolute';
        tick.style[isVertical ? 'height' : 'width'] = '0px';
        tick.style[isVertical ? 'width' : 'height'] = `${segmentDimension}px`;
        tick.style[isVertical ? 'top' : 'left'] = `${
          i * unit - 1 + unit * extraSpace
        }px`;
        tick.style.border = '1px solid blue';
        axisContainer.appendChild(tick);
        ticks.push(tick);
      }

      const indexLo = createPointerCircle(
        pointerRadius, // Circle radius
        isVertical ? segmentDimension / 2 : (currIndexLo + extraSpace) * unit, // X for vertical, left for horizontal
        isVertical ? (currIndexLo + extraspace) * unit : segmentDimension / 2, // Y for vertical, top for horizontal
        pointerColorNonSelected
      );
      axisContainer.appendChild(indexLo);

      const indexHi = createPointerCircle(
        pointerRadius, // Circle radius
        isVertical ? segmentDimension / 2 : (currIndexHi + extraSpace) * unit, // X for vertical, left for horizontal
        isVertical ? (currIndexHi + extraSpace) * unit : segmentDimension / 2, // Y for vertical, top for horizontal
        pointerColorNonSelected
      );
      axisContainer.appendChild(indexHi);

      const updateColors = () => {
        ticks.forEach((tick, index) => {
          if (index < currIndexLo) {
            tick.style.backgroundColor = axisColorLo;
          } else if (index > currIndexLo && index < currIndexHi) {
            tick.style.backgroundColor = axisColorIn;
          } else {
            tick.style.backgroundColor = axisColorHi;
          }
        });

        segments.forEach((segment, index) => {
          if (index < currIndexLo) {
            segment.style.backgroundColor = axisColorLo;
          } else if (index >= currIndexLo && index < currIndexHi) {
            segment.style.backgroundColor = axisColorIn;
          } else {
            segment.style.backgroundColor = axisColorHi;
          }
        });
      };

      let isLoDragging = false;
      let isHiDragging = false;
      let selectedElement = null;

      const updateSelection = (element) => {
        if (selectedElement) {
          selectedElement.style.backgroundColor = pointerColorNonSelected;
        }
        element.style.backgroundColor = pointerColorSelected;
        selectedElement = element;
      };

      indexLo.addEventListener('mousedown', (event) => {
        isLoDragging = true;
        updateSelection(indexLo);
        event.preventDefault();
      });

      indexHi.addEventListener('mousedown', (event) => {
        isHiDragging = true;
        updateSelection(indexHi);
        event.preventDefault();
      });

      window.addEventListener('mouseup', () => {
        isLoDragging = false;
        isHiDragging = false;
      });

      window.addEventListener('mousemove', (event) => {
        if (isLoDragging || isHiDragging) {
          const rect = axisContainer.getBoundingClientRect();
          let mousePos = isVertical
            ? event.clientY - rect.top
            : event.clientX - rect.left;

          const minLimit = isLoDragging ? 0 : (currIndexLo + 1) * unit;
          const maxLimit = isLoDragging ? (currIndexHi - 1) * unit : X;
          mousePos = Math.max(minLimit, Math.min(mousePos, maxLimit));
          const snappedIndex = Math.round(mousePos / unit);
          const element = isLoDragging ? indexLo : indexHi;
          const isCurrLo = isLoDragging;

          if (isVertical) {
            element.style.top = `${
              snappedIndex * unit - pointerRadius / 2 + unit * extraSpace
            }px`;
          } else {
            element.style.left = `${
              snappedIndex * unit - pointerRadius / 2 + unit * extraSpace
            }px`;
          }

          if (isCurrLo) currIndexLo = snappedIndex;
          else currIndexHi = snappedIndex;

          updateColors();
        }
      });

      window.addEventListener('keydown', (event) => {
        if (!selectedElement) {
          if (event.key === 'Tab') {
            event.preventDefault();
            updateSelection(indexLo);
          }
          return;
        }

        if (event.key === 'Tab') {
          event.preventDefault();
          if (!event.shiftKey) {
            updateSelection(indexHi);
          } else {
            updateSelection(indexLo);
          }
          return;
        }

        let currIndex, element, minLimit, maxLimit;

        if (selectedElement === indexLo) {
          currIndex = currIndexLo;
          element = indexLo;
          minLimit = 0;
          maxLimit = currIndexHi - 1;
        } else if (selectedElement === indexHi) {
          currIndex = currIndexHi;
          element = indexHi;
          minLimit = currIndexLo + 1;
          maxLimit = Y - 1;
        }

        if (
          event.key === 'ArrowLeft' ||
          (isVertical && event.key === 'ArrowUp') ||
          (!isVertical && event.key === 'ArrowDown')
        ) {
          currIndex = Math.max(minLimit, currIndex - 1);
        } else if (
          event.key === 'ArrowRight' ||
          (!isVertical && event.key === 'ArrowUp') ||
          (isVertical && event.key === 'ArrowDown')
        ) {
          currIndex = Math.min(maxLimit, currIndex + 1);
        } else {
          return;
        }

        const snappedPos = currIndex * unit;

        isVertical
          ? (element.style.top = `${
              snappedPos - pointerRadius / 2 + unit * extraSpace
            }px`)
          : (element.style.left = `${
              snappedPos - pointerRadius / 2 + unit * extraSpace
            }px`);

        if (selectedElement === indexLo) {
          currIndexLo = currIndex;
        } else if (selectedElement === indexHi) {
          currIndexHi = currIndex;
        }

        updateColors();
      });

      updateColors();
    </script>
  </body>
</html>
